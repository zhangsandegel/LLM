[TOC]



# 面试代码题





## 动态规划



### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)



### [32. 最长有效括号](https://leetcode.cn/problems/longest-valid-parentheses/)

![image-20250919152457844](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919152457844.png)

---

**解题思路**

- **状态定义**：设 `dp[i]` 表示以索引 `i` 结尾的最长有效括号子串的长度。
- 状态转移：
  - 当 `s[i] == '('` 时，`dp[i] = 0`，因为以左括号结尾的子串不可能是有效括号子串。
  - 当`s[i] == ')'`时：
    - 如果 `s[i - 1] == '('`，那么 `dp[i] = dp[i - 2] + 2`（此时 `i - 1` 和 `i` 组成一个有效括号对，再加上前面的有效长度）。
    - 如果 `s[i - 1] == ')'`，且 `i - dp[i - 1] - 1 >= 0` 且 `s[i - dp[i - 1] - 1] == '('`，那么 `dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2`（此时需要检查前面是否有对应的左括号，然后将当前有效长度与前面的有效长度连接起来）。
- **初始状态**：`dp[0] = 0`，因为单个字符不可能是有效括号子串。



----

```python
def longestValidParentheses(s):
    n = len(s)
    if n < 2:
        return 0
    dp = [0] * n
    max_len = 0
    
    for i in range(1, n):
        if s[i] == ')':
            # 情况1：当前右括号与前一个字符组成"()"
            if s[i-1] == '(':
                # 如果前面还有字符，加上之前的有效长度；否则直接为2
                dp[i] = dp[i-2] + 2 if i >= 2 else 2
            
            # 情况2：当前右括号与前面的有效子串组成嵌套结构，如"(...)"
            elif i - dp[i-1] > 0 and s[i - dp[i-1] - 1] == '(':
                # 基础长度是前面有效子串长度+2（当前匹配的一对括号）
                base = dp[i-1] + 2
                # 如果前面还有有效子串，需要累加
                if i - dp[i-1] >= 2:
                    base += dp[i - dp[i-1] - 2]
                dp[i] = base
            
            # 更新最长有效长度
            if dp[i] > max_len:
                max_len = dp[i]
    
    return max_len

# 测试示例
s1 = "(()"
print(longestValidParentheses(s1))  # 输出: 2（正确，对应"()"）

s2 = ")()())"
print(longestValidParentheses(s2))  # 输出: 4（正确，对应"()()"）

s3 = ""
print(longestValidParentheses(s3))  # 输出: 0（正确）

s4 = "()(())"
print(longestValidParentheses(s4))  # 输出: 6（正确，整个字符串有效）

s5 = "()())()()"
print(longestValidParentheses(s5))  # 输出: 4（正确，对应"()()"）

```

## 多维动态规划

### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)

![image-20250919151528451](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919151528451.png)

---

**解题思路**

**到达当前位置的路径总数 = 所有可能来源的路径数之和**，而由于机器人只能向右 / 向下移动，来源只有「上方」和「左边」两个方向，因此用加法合并这两个方向的路径数。

- **状态定义**：设 `dp[i][j]` 表示从左上角走到第 `i` 行第 `j` 列位置时的不同路径数。
- 状态转移：
  - 对于第一行（`i = 0`），只能从左边过来，所以 `dp[0][j] = 1`。
  - 对于第一列（`j = 0`），只能从上面过来，所以 `dp[i][0] = 1`。
  - 对于其他位置（`i > 0` 且 `j > 0`），可以从上面或左边过来，所以 `dp[i][j] = dp[i - 1][j] + dp[i][j - 1]`。
- **初始状态**：`dp[0][0] = 1`，表示在起点只有 1 种路径（就是自身）。

----

```python
def uniquePaths(m, n):
    # 创建二维动态规划数组
    dp = [[1] * n for _ in range(m)]
    # 填充dp数组
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    # 返回右下角的路径数
    return dp[m - 1][n - 1]
# 测试示例
print(uniquePaths(3, 7))  # 输出: 28
print(uniquePaths(3, 2))  # 输出: 3
print(uniquePaths(7, 3))  # 输出: 28
print(uniquePaths(3, 3))  # 输出: 6
```



### [64. 最小路径和](https://leetcode.cn/problems/minimum-path-sum/)

![image-20250919150811299](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919150811299.png)

---

**解题思路**

- **状态定义**：设 `dp[i][j]` 表示从左上角走到网格中第 `i` 行第 `j` 列位置时的最小路径和。
- 状态转移：
  - 对于第一行（`i = 0`），只能从左边过来，所以 `dp[0][j] = dp[0][j - 1] + grid[0][j]`。
  - 对于第一列（`j = 0`），只能从上面过来，所以 `dp[i][0] = dp[i - 1][0] + grid[i][0]`。
  - 对于其他位置（`i > 0` 且 `j > 0`），可以从上面或左边过来，所以 `dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]`。
- **初始状态**：`dp[0][0] = grid[0][0]`，即左上角位置的路径和就是其本身的值。

---

```python
def minPathSum(grid):
    m, n = len(grid), len(grid[0])
    # 创建二维动态规划数组
    dp = [[0] * n for _ in range(m)]
    # 初始化左上角
    dp[0][0] = grid[0][0]
    # 初始化第一列
    for i in range(1, m):
        dp[i][0] = dp[i - 1][0] + grid[i][0]
    # 初始化第一行
    for j in range(1, n):
        dp[0][j] = dp[0][j - 1] + grid[0][j]
    # 填充dp数组
    for i in range(1, m):
        for j in range(1, n):
            dp[i][j] = min(dp[i - 1][j], dp[i][j - 1]) + grid[i][j]
    # 返回右下角的最小路径和
    return dp[m - 1][n - 1]
# 测试示例
grid1 = [[1, 3, 1], [1, 5, 1], [4, 2, 1]]
print(minPathSum(grid1))  # 输出: 7

grid2 = [[1, 2, 3], [4, 5, 6]]
print(minPathSum(grid2))  # 输出: 12
```



### [5. 最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/)

![image-20250919145415822](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919145415822.png)

---

● 遍历每一个字符，把每个字符（奇数回文中心）和相邻字符对（偶数回文中心）作为中心，向两边扩展，直到不是回文。

 ● 记录每次扩展得到的最大长度和对应下标。

时间复杂度：$O(n^2)$，每个字符都尝试作为中心扩展，最多扩展 n 次。

空间复杂度：O(1)，只需记录结果的起止位置。

---

```python
def longestPalindrome(s):
    if len(s) < 2:
        return s

    def expand_around_center(left, right):
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        # 返回以left和right为中心扩展得到的回文子串
        return s[left + 1:right]

    max_palindrome = ""
    for i in range(len(s)):
        # 奇数长度回文子串，中心是s[i]
        palindrome1 = expand_around_center(i, i)
        # 偶数长度回文子串，中心是s[i]和s[i + 1]
        palindrome2 = expand_around_center(i, i + 1)
        # 更新最长回文子串
        current_max = palindrome1 if len(palindrome1) > len(palindrome2) else palindrome2
        if len(current_max) > len(max_palindrome):
            max_palindrome = current_max
    return max_palindrome
# 测试示例
s1 = "babad"
print(longestPalindrome(s1))  # 输出: "bab" 或 "aba"

s2 = "cbbd"
print(longestPalindrome(s2))  # 输出: "bb"
```

```python
class Solution:
    def longestPalindrome(self,s:str)->str:
        if len(s)<2:
            return s
        
        def expand_center(left,right):
            while left>=0 and right<len(s) and s[left] == s[right]:
                left-=1
                right +=1
            return s[left+1:right]
        
        max = ""
        for i in range(len(s)):
            s1 = expand_center(i,i)
            s2 = expand_center(i,i+1)
            curr_max = s1 if len(s1) > len(s2) else s2
            if len(curr_max) > len(max):
                max = curr_max
        return max
```



### [1143. 最长公共子序列](https://leetcode.cn/problems/longest-common-subsequence/)

![image-20250919143734112](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919143734112.png)

---

**解题思路**

- **状态定义**：设 `dp[i][j]` 表示 `text1` 的前 `i` 个字符和 `text2` 的前 `j` 个字符的最长公共子序列的长度。
- 状态转移：
  - 如果 `text1[i - 1] == text2[j - 1]`，那么 `dp[i][j] = dp[i - 1][j - 1] + 1`，因为当前字符相同，最长公共子序列长度在之前的基础上加 1。
  - 否则，`dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])`，即取 `text1` 前 `i - 1` 个字符与 `text2` 前 `j` 个字符的最长公共子序列长度，和 `text1` 前 `i` 个字符与 `text2` 前 `j - 1` 个字符的最长公共子序列长度中的最大值。
- **初始状态**：`dp[i][0] = 0`（`text2` 为空字符串时，最长公共子序列长度为 0），`dp[0][j] = 0`（`text1` 为空字符串时，最长公共子序列长度为 0）。

**时间复杂度**

- **时间复杂度为 O (m×n)**，其中 `m` 和 `n` 分别是两个输入字符串 `text1` 和 `text2` 的长度。
- 原因：算法需要填充一个 `(m+1)×(n+1)` 的二维 DP 表格，每个表格中的每个单元格都需要进行一次计算（要么直接取值，要么进行一次比较或加法操作），这些操作都是常数时间 O (1)。因此总时间复杂度由表格的大小决定，即 O (m×n)。

**空间复杂度**

- **空间复杂度为 O (m×n)**，同样由 DP 表格的大小决定。
- 我们需要创建一个 `(m+1)×(n+1)` 的二维数组来存储所有子问题的解，因此需要占用 O (m×n) 的额外空间。

---

```python
def longestCommonSubsequence(text1, text2):
    m, n = len(text1), len(text2)
    # 创建二维动态规划数组，大小为(m + 1)×(n + 1)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # 如果当前字符相同
            if text1[i - 1] == text2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                # 取两种情况中的最大值
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    # 返回text1和text2的最长公共子序列长度
    return dp[m][n]
  
# 测试示例
text1_1, text2_1 = "abcde", "ace"
print(longestCommonSubsequence(text1_1, text2_1))  # 输出: 3

text1_2, text2_2 = "abc", "abc"
print(longestCommonSubsequence(text1_2, text2_2))  # 输出: 3

text1_3, text2_3 = "abc", "def"
print(longestCommonSubsequence(text1_3, text2_3))  # 输出: 0
```

### [72. 编辑距离](https://leetcode.cn/problems/edit-distance/)

<img src="/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919141845892.png" alt="image-20250919141845892" style="zoom:50%;" />

---

**解题思路**

- **状态定义**：设 `dp[i][j]` 表示将 `word1` 的前 `i` 个字符转换为 `word2` 的前 `j` 个字符所需的最少操作数。
- 状态转移：
  - 如果 `word1[i - 1] == word2[j - 1]`，那么 `dp[i][j] = dp[i - 1][j - 1]`，因为当前字符相同，不需要操作。
  - 否则，`dp[i][j] = 1 + min(dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1])`，分别对应删除、插入、替换操作。
- **初始状态**：`dp[i][0] = i`（将 `word1` 的前 `i` 个字符删除，得到空字符串，操作数为 `i`），`dp[0][j] = j`（插入 `j` 个字符，得到 `word2` 的前 `j` 个字符，操作数为 `j`）。

**时间复杂度**

- 时间复杂度为 $O(m \times n)$，其中 m 和 n 分别是两个输入字符串 `word1` 和 `word2` 的长度。
- 原因：算法需要填充一个$((m+1) \times (n+1))$的二维 DP 表格，对于表格中的每个单元格，都需要进行一次计算（判断字符是否相等，然后根据情况取最小值并进行简单的算术操作），这些操作的时间复杂度都是 \(O(1)\)。所以总的时间复杂度由表格的大小决定，即 \(O(m \times n)\)。

**空间复杂度**

- 空间复杂度为 $O(m \times n)$，由二维 DP 表格的大小决定。
- 我们需要创建一个 $(m + 1) \times (n + 1)$的二维数组来存储所有子问题的解，因此需要占用 $O(m \times n)$的额外空间。

---

```python
def minDistance(word1, word2):
    # 获取两个字符串的长度
    m, n = len(word1), len(word2)
    
    # 创建一个(m+1)x(n+1)的二维数组dp，用于存储中间结果
    # dp[i][j]表示将word1的前i个字符转换为word2的前j个字符所需的最少操作数
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 初始化第一列：将word1的前i个字符转换为空字符串
    # 只需要删除i个字符，所以操作数为i
    for i in range(m + 1):
        dp[i][0] = i
    
    # 初始化第一行：将空字符串转换为word2的前j个字符
    # 只需要插入j个字符，所以操作数为j
    for j in range(n + 1):
        dp[0][j] = j
    
    # 填充dp数组
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            # 如果当前字符相同，不需要操作
            # 直接继承dp[i-1][j-1]的值
            if word1[i - 1] == word2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1]
            else:
                # 如果当前字符不同，取以下三种操作的最小值加1
                # 1. dp[i-1][j]：删除word1的第i个字符
                # 2. dp[i][j-1]：插入word2的第j个字符到word1
                # 3. dp[i-1][j-1]：将word1的第i个字符替换为word2的第j个字符
                dp[i][j] = 1 + min(dp[i - 1][j],    # 删除
                                   dp[i][j - 1],    # 插入
                                   dp[i - 1][j - 1])# 替换
    
    # dp[m][n]就是将整个word1转换为整个word2所需的最少操作数
    return dp[m][n]
```

## 技巧

### [136. 只出现一次的数字](https://leetcode.cn/problems/single-number/)

<img src="/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919141139947.png" alt="image-20250919141139947" style="zoom:50%;" />

----

我们可以使用异或运算来解决这个问题。**异或运**算有一个特性：==任何数和它本身进行异或运算结果为0，任何数和0进行异或运算结果还是它本身==。由于数组中除了一个元素只出现一次，其余元素都出现两次，那么将数组中所有元素依次进行异或运算，最后剩下的结果就是只出现一次的那个元素。

**复杂度分析**

- **时间复杂度**：\(O(n)\)，其中n是数组的长度。我们只需要遍历数组一次。
- **空间复杂度**：\(O(1)\)，只使用了常数级别的额外空间。

---

```python
def singleNumber(nums):
    result = 0
    for num in nums:
        result ^= num
    return result
# 测试示例
nums1 = [2, 2, 1]
print(singleNumber(nums1))  # 输出: 1

nums2 = [4, 1, 2, 1, 2]
print(singleNumber(nums2))  # 输出: 4

nums3 = [1]
print(singleNumber(nums3))  # 输出: 1
```



### [169. 多数元素](https://leetcode.cn/problems/majority-element/)

![image-20250919114704005](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919114704005.png)

---

我们可以使用摩尔投票法来解决这个问题，这种方法的核心思想是：在每一轮投票过程中，从数组中找出一对不同的元素，将其从数组中删除。由于多数元素的数量大于数组长度的一半，所以最终剩下的元素一定是多数元素。

---

```python

```



### [75. 颜色分类](https://leetcode.cn/problems/sort-colors/)

![image-20250919112017228](/Users/zhangyu/Library/Application Support/typora-user-images/image-20250919112017228.png)

----

**荷兰国旗荷兰国旗问题（三色排序）的原理**

荷兰国旗问题的核心是将包含三种元素（通常用 0、1、2 表示）的数组进行排序，要求最终结果中所有 0 在最前面，所有 1 在中间，所有 2 在最后面。

**核心原理**：
使用三指针法（荷兰国旗算法），通过一次遍历完成排序，避免使用额外空间：

1. **左指针（left）**：标记下一个 0 应该放置的位置（初始值为 0）
2. **右指针（right）**：标记下一个 2 应该放置的位置（初始值为数组末尾）
3. **当前指针（current）**：用于遍历数组（初始值为 0）

**工作流程**：

- 当`current`指向 0 时：与`left`位置元素交换，`left`和`current`都右移（因为交换过来的一定是 1）
- 当`current`指向 2 时：与`right`位置元素交换，`right`左移（`current`不移动，因为交换过来的元素可能是 0）
- 当`current`指向 1 时：直接右移（1 的位置暂时不需要调整）
- 循环终止条件：`current`超过`right`（表示所有元素已处理完毕）

**时空复杂度分析**

**时间复杂度**：O(n)

- 数组中的每个元素最多被访问一次（`current`指针从 0 移动到`right`）
- 所有交换操作都是常数时间 O (1)
- 整个过程只需一次线性遍历，因此时间复杂度为线性级别

**空间复杂度**：O(1)

- 算法仅使用了 3 个额外指针（left、right、current）
- 排序操作在原数组上进行（原地排序），不需要额外的数组空间
- 因此空间复杂度为常数级别

这种算法的优势在于：用线性时间和常数空间解决了三色排序问题，效率优于先计数再重构数组的方法（虽然时间复杂度相同，但避免了两次遍历）。

---



```python
def sortColors(nums):
    # 左指针，指向已排序好的 0 的下一个位置
    left = 0
    # 右指针，指向已排序好的 2 的前一个位置
    right = len(nums) - 1
    # 当前遍历的指针
    current = 0
    while current <= right:
        if nums[current] == 0:
            # 如果当前元素是 0，交换到左边
            nums[current], nums[left] = nums[left], nums[current]
            left += 1
            current += 1
        elif nums[current] == 2:
            # 如果当前元素是 2，交换到右边
            nums[current], nums[right] = nums[right], nums[current]
            right -= 1
        else:
            # 如果当前元素是 1，继续向后遍历
            current += 1
# 测试示例
nums1 = [2, 0, 2, 1, 1, 0]
sortColors(nums1)
print(nums1)  # 输出: [0, 0, 1, 1, 2, 2]

nums2 = [2, 0, 1]
sortColors(nums2)
print(nums2)  # 输出: [0, 1, 2]
```



### [31. 下一个排列](https://leetcode.cn/problems/next-permutation/)

<img src="/Users/zhangyu/Library/Application Support/typora-user-images/image-20250917175542540.png" alt="image-20250917175542540" style="zoom:50%;" />

---

**解题思路：**

我们可以通过以下步骤来找到数组的下一个排列：

1. **从后向前找第一个升序对**：从数组的末尾开始，找到第一个满足 `nums[i] < nums[i + 1]` 的位置 `i`。这一步是为了确定可以调整的起始位置，因为从 `i` 之后的部分是降序的，无法再通过交换后面的元素得到更大的排列，需要调整 `i` 位置的元素。
2. **从后向前找比 nums [i] 大的最小数**：在 `i` 之后的降序部分中，从末尾开始找到第一个比 `nums[i]` 大的数 `nums[j]`，然后交换 `nums[i]` 和 `nums[j]`。这样可以保证在 `i` 位置得到一个更大的数，同时尽可能小地增大整个排列。
3. **反转 i 之后的部分**：交换之后，`i` 之后的部分仍然是降序的，将其反转成升序，这样就能得到最小的更大排列。如果找不到步骤 1 中的 `i`（即数组本身是降序的），则直接反转整个数组，得到最小的排列。

**时间复杂度：**

- 首先，在寻找第一个升序对的过程中，最多遍历数组的后半部分，时间复杂度为 \(O(n)\)。
- 然后，寻找比 `nums[i]` 大的最小数，同样最多遍历数组的后半部分，时间复杂度为 \(O(n)\)。
- 最后，反转 `i` 之后的部分，最多遍历数组的后半部分，时间复杂度为 \(O(n)\)。
- 所以，总的时间复杂度为 \(O(n)\)，其中 n 是数组的长度。

**空间复杂度**:

- 算法中只使用了常数个额外变量（如 `i`、`j`、`left`、`right` 等），没有使用额外的数组或其他数据结构，所以空间复杂度为 \(O(1)\)。

------------

```python
def nextPermutation(nums):
    n = len(nums)
    # 步骤1：从后向前找第一个升序对
    i = n - 2
    while i >= 0 and nums[i] >= nums[i + 1]:
        i -= 1
    if i >= 0:
        # 步骤2：从后向前找比nums[i]大的最小数
        j = n - 1
        while nums[j] <= nums[i]:
            j -= 1
        # 交换nums[i]和nums[j]
        nums[i], nums[j] = nums[j], nums[i]
    # 步骤3：反转i之后的部分
    left, right = i + 1, n - 1
    while left < right:
        nums[left], nums[right] = nums[right], nums[left]
        left += 1
        right -= 1
    return nums
```

### [287. 寻找重复数](https://leetcode.cn/problems/find-the-duplicate-number/)

<img src="/Users/zhangyu/Library/Application Support/typora-user-images/image-20250917174202618.png" alt="image-20250917174202618" style="zoom:50%;" />

----

**解题思路**:

1. 因为数组中的数字都在 `[1, n]` 范围内，所以我们可以在这个区间上进行二分查找。
2. 对于中间值 `mid`，统计数组中小于等于 `mid` 的元素个数 `count`。
3. 如果 `count` 大于 `mid`，说明重复的数字在 `[1, mid]` 之间；否则，重复的数字在 `[mid + 1, n]` 之间。
4. 不断缩小范围，最终找到重复的数字。

这种方法的时间复杂度是$O(n \log n)$ ，空间复杂度是$ O(1)$，符合题目要求

- 首先，初始化 `left` 为 `1`，`right` 为数组长度减 `1`（因为数组有 `n + 1` 个元素，数字范围是 `[1, n]`）。
- 然后，在 `while` 循环中，计算中间值 `mid`，并统计数组中小于等于 `mid` 的元素个数 `count`。
- 根据 `count` 和 `mid` 的大小关系，调整 `left` 或 `right` 的值，缩小查找范围。
- 当 `left` 等于 `right` 时，就找到了重复的数字并返回。

---

```python
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        left,right = 1,len(nums)-1
        while left < right:
            mid = (left + right) //2
            count = 0
            for num in nums:
                if num <= mid:
                    count+=1
            if count > mid:
                right = mid
            else:
                left = mid + 1
        return left
```



